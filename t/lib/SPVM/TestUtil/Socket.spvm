class TestUtil::Socket extends IO::Socket::IP  {
  
  use Sys::Socket::Errno;
  use Sys::Socket::Sockaddr;
  use Net::SSLeay::Constant as SSL;
  
  # Fields
  has ssl : rw Net::SSLeay;
  
  # Class Methods
  static method new : TestUtil::Socket ($options : object[] = undef) {
    
    my $self = new TestUtil::Socket;
    
    $self->init($options);
    
    $self->configure;
    
    return $self;
  }
  
  # Instance Methods
  protected method configure : void () {
    
    $self->SUPER::configure;
    
    $self->configure_SSL;
  }
  
  protected method init : void ($options : object[] = undef) {
    
    $self->SUPER::init($options);
    
  }
  
  protected method configure_SSL : void () {
    
    my $ssl_method = Net::SSLeay::SSL_METHOD->TLS_method;
    
    my $ssl_ctx = Net::SSLeay::SSL_CTX->new($ssl_method);
    
    my $ssl = Net::SSLeay->new($ssl_ctx);
    
    warn $ssl;
    
    my $socket_fileno = $self->fileno;
    
    $ssl->set_fd($socket_fileno);
    
    $self->{ssl} = $ssl;
    
  }
  
  method connect_SSL : void () {
    
    my $ssl = $self->{ssl};
    
    my $timeout = $self->{Timeout};
    
    my $fd = $self->{FD};
    
    while (1) {
      eval { $ssl->connect; }
      
      if ($@) {
        my $again_read = eval_error_id isa_error Net::SSLeay::Error::SSL_ERROR_WANT_READ;
        
        my $again_write = eval_error_id isa_error Net::SSLeay::Error::SSL_ERROR_WANT_WRITE;
        
        if ($again_read) {
          Go->gosched_io_read($fd, $timeout);
          next;
        }
        elsif ($again_write) {
          Go->gosched_io_write($fd, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
  }

=pod

  method accept : TestUtil::Socket ($peer_ref : Sys::Socket::Sockaddr[] = undef) {
    
    my $client_socket = (TestUtil::Socket)$self->SUPER::accept($peer_ref);
    
    $client_socket = undef;
    
    # my $ssl_ctx = $self->ssl->get_SSL_CTX;
    
    # $client_socket->ssl->set_SSL_CTX($ssl_ctx);
    
    return $client_socket;
  }

=cut

  method accept : TestUtil::Socket ($peer_ref : Sys::Socket::Sockaddr[] = undef) {
    
    my $fd = $self->{FD};
    
    my $timeout = $self->{Timeout};
    
    my $client_fd = -1;
    my $client_sockaddr = (Sys::Socket::Sockaddr)undef;
    
    while (1) {
      eval { $client_sockaddr = Sys->accept(\$client_fd, $fd); }
      
      if ($@) {
        my $again = Sys::Socket::Errno->is_accept_again(Sys::Socket::Errno->errno);
        
        if ($again) {
          Go->gosched_io_read($fd, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
    
    my $options = {
      Timeout => $timeout,
      FD => $client_fd,
      Domain => $self->{Domain},
      Type => $self->{Type},
      Proto => $self->{Proto},
    };
    
    my $class = type_name $self;
    my $client = TestUtil::Socket->new($options);
    
    if ($peer_ref) {
      $peer_ref->[0] = $client_sockaddr;
    }
    
    return $client;
  }

  method accept_SSL : void () {
    
    my $ssl = $self->{ssl};
    
    my $fd = $self->{FD};
    
    my $timeout = $self->{Timeout};
    
    while (1) {
      eval { $ssl->accept; }
      
      if ($@) {
        my $again_read = eval_error_id isa_error Net::SSLeay::Error::SSL_ERROR_WANT_READ;
        
        my $again_write = eval_error_id isa_error Net::SSLeay::Error::SSL_ERROR_WANT_WRITE;
        
        if ($again_read) {
          Go->gosched_io_read($fd, $timeout);
          next;
        }
        elsif ($again_write) {
          Go->gosched_io_write($fd, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
  }
  
  method read : int ($buffer : mutable string, $length : int = -1, $offset : int = 0) {
    
    my $ssl = $self->{ssl};
    
    my $fd = $self->{FD};
    
    my $timeout = $self->{Timeout};
    
    my $read_length = -1;
    while (1) {
      eval { $read_length = $ssl->read($buffer, $length, $offset); }
      
      if ($@) {
        my $again_read = eval_error_id isa_error Net::SSLeay::Error::SSL_ERROR_WANT_READ;
        
        my $again_write = eval_error_id isa_error Net::SSLeay::Error::SSL_ERROR_WANT_WRITE;
        
        if ($again_read) {
          Go->gosched_io_read($fd, $timeout);
          next;
        }
        elsif ($again_write) {
          Go->gosched_io_write($fd, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
    
    return $read_length;
  }
  
  method write : int ($buffer : string, $length : int = -1, $offset : int = 0) {
    
    my $ssl = $self->{ssl};
    
    my $fd = $self->{FD};
    
    my $timeout = $self->{Timeout};
    
    my $write_length = -1;
    while (1) {
      
      eval { $write_length = $ssl->write($buffer, $length, $offset); }
      
      if ($@) {
        my $again_read = eval_error_id isa_error Net::SSLeay::Error::SSL_ERROR_WANT_READ;
        
        my $again_write = eval_error_id isa_error Net::SSLeay::Error::SSL_ERROR_WANT_WRITE;
        
        if ($again_read) {
          Go->gosched_io_read($fd, $timeout);
          next;
        }
        elsif ($again_write) {
          Go->gosched_io_write($fd, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
    
    return $write_length;
  }
  
  method shutdown_SSL : int () {
    
    my $ssl = $self->{ssl};
    
    my $fd = $self->{FD};
    
    my $timeout = $self->{Timeout};
    
    my $status = -1;
    while (1) {
      
      eval { $status = $ssl->shutdown; }
      
      if ($@) {
        my $again_read = eval_error_id isa_error Net::SSLeay::Error::SSL_ERROR_WANT_READ;
        
        my $again_write = eval_error_id isa_error Net::SSLeay::Error::SSL_ERROR_WANT_WRITE;
        
        if ($again_read) {
          Go->gosched_io_read($fd, $timeout);
          next;
        }
        elsif ($again_write) {
          Go->gosched_io_write($fd, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
    
    return $status;
  }
  
  method close : void () {
    
    my $ssl = $self->{ssl};
    
    my $shutdown_status = $ssl->get_shutdown;
    
    my $listen = $self->{Listen};
    
    # Only client sockets and accpected sockets
    unless ($listen > 0) {
      $self->shutdown_SSL;
    }
    
    $self->SUPER::close;
    
  }
  
  method DESTROY : void () {
    $self->close;
  }

}
