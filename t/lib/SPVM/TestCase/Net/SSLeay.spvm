class TestCase::Net::SSLeay {
  use IO::Socket::IP;
  use Net::SSLeay;
  use Net::SSLeay::SSL_CTX;
  use Net::SSLeay::SSL_METHOD;
  use Net::SSLeay::Constant as SSL;
  use Net::SSLeay::ERR;
  use StringBuffer;
  use Mozilla::CA;
  use Sys::Signal::Constant as SIGNAL;
  use Net::SSLeay::Error;
  
  use Net::SSLeay::OBJ;
  use Net::SSLeay::X509;
  use Net::SSLeay::X509_NAME;
  use Net::SSLeay::X509_NAME_ENTRY;
  use Sys::OS;
  use Net::SSLeay::ASN1_ENUMERATED;
  use Net::SSLeay::ASN1_INTEGER;
  use Net::SSLeay::ASN1_STRING;
  use Net::SSLeay::ASN1_OCTET_STRING;
  use Sys::Time::Tm;
  use Net::SSLeay::ASN1_TIME;
  use Net::SSLeay::OBJ;
  use Net::SSLeay::BIO;
  use FindBin;
  use Net::SSLeay::PEM;
  use Net::SSLeay::EVP_MD;
  use Net::SSLeay::EVP;
  use Net::SSLeay::OPENSSL_INIT;
  use Net::SSLeay::OPENSSL_INIT_SETTINGS;
  
  our $FILE_DIR : string;
  
  INIT {
    $FILE_DIR = FindBin->Bin . "/file";
  }
  
  static method test : int () {
    
    my $version = SSL->OPENSSL_VERSION_TEXT;
    
    warn "[Test Output]OpenSSL version:$version";
    
    # Socket
    my $host = "www.google.com";
    my $port = 443;
    my $socket = IO::Socket::IP->new({PeerAddr => $host, PeerPort => $port});
    
    my $ssl_method = Net::SSLeay::SSL_METHOD->TLS_method;
    
    my $ssl_ctx = Net::SSLeay::SSL_CTX->new($ssl_method);
    
    $ssl_ctx->set_verify(SSL->SSL_VERIFY_PEER);
    
    $ssl_ctx->set_default_verify_paths;
    
    my $ca = Mozilla::CA->SSL_ca;
    
    my $bio = Net::SSLeay::BIO->new;
    
    $bio->write($ca);
    
    my $x509 = Net::SSLeay::PEM->read_bio_X509($bio);
    
    my $x509_store = $ssl_ctx->get_cert_store;
    
    $x509_store->add_cert($x509);
    
    my $verify_param = $ssl_ctx->get0_param;
    
    $verify_param->set_hostflags(SSL->X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS);
    
    $verify_param->set1_host($host);
    
    my $ssl = Net::SSLeay->new($ssl_ctx);
    
    my $socket_fileno = $socket->fileno;
    
    $ssl->set_fd($socket_fileno);
    
    $ssl->set_tlsext_host_name($host);
    
    my $timeout = 0;
    
    while (1) {
      eval { $ssl->connect; }
      
      if ($@) {
        my $again = Sys::Socket::Errno->is_connect_again(Sys::Socket::Errno->errno);
        
        if ($again) {
          Go->gosched_io_write($socket_fileno, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
    
    my $send_buffer = "GET / HTTP/1.0\r\n\r\n";
    $ssl->write($send_buffer);
    
    my $buffer = StringBuffer->new;
    
    my $recv_buffer = (mutable string)new_string_len 100;
    while (1) {
      my $recv_length = &read($ssl, $socket_fileno, 0, $recv_buffer);
      
      if ($recv_length > 0) {
        $buffer->push($recv_buffer, 0, $recv_length);
        # print $recv_buffer;
      }
      
      if ($recv_length < 0) {
        die "Read error";
      }
      
      if ($recv_length < length $recv_buffer) {
        last;
      }
    }
    
    my $shutdown_ret = $ssl->shutdown;
    
    $socket->close;
    
    unless (Fn->contains($buffer->to_string, "google.com")) {
      return 0;
    }
    
    return 1;
  }
  
  static method test_no_mozilla_ca : int () {
    
    my $version = SSL->OPENSSL_VERSION_TEXT;
    
    # Socket
    my $host = "www.google.com";
    my $port = 443;
    my $socket = IO::Socket::IP->new({PeerAddr => $host, PeerPort => $port});
    
    my $ssl_method = Net::SSLeay::SSL_METHOD->TLS_method;
    
    my $ssl_ctx = Net::SSLeay::SSL_CTX->new($ssl_method);
    
    $ssl_ctx->set_verify(SSL->SSL_VERIFY_PEER);
    
    if (Sys::OS->is_windows) {
      $ssl_ctx->set_default_verify_paths_windows;
    }
    else {
      $ssl_ctx->set_default_verify_paths;
    }
    
    my $verify_param = $ssl_ctx->get0_param;
    
    $verify_param->set_hostflags(SSL->X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS);
    
    $verify_param->set1_host($host);
    
    my $ssl = Net::SSLeay->new($ssl_ctx);
    
    my $socket_fileno = $socket->fileno;
    
    $ssl->set_fd($socket_fileno);
    
    $ssl->set_tlsext_host_name($host);
    
    my $timeout = 0;
    
    while (1) {
      eval { $ssl->connect; }
      
      if ($@) {
        my $again = Sys::Socket::Errno->is_connect_again(Sys::Socket::Errno->errno);
        
        if ($again) {
          Go->gosched_io_write($socket_fileno, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
    
    my $send_buffer = "GET / HTTP/1.0\r\n\r\n";
    $ssl->write($send_buffer);
    
    my $buffer = StringBuffer->new;
    
    my $recv_buffer = (mutable string)new_string_len 100;
    while (1) {
      my $recv_length = &read($ssl, $socket_fileno, 0, $recv_buffer);
      
      if ($recv_length > 0) {
        $buffer->push($recv_buffer, 0, $recv_length);
        # print $recv_buffer;
      }
      
      if ($recv_length < 0) {
        die "Read error";
      }
      
      if ($recv_length < length $recv_buffer) {
        last;
      }
    }
    
    my $shutdown_ret = $ssl->shutdown;
    
    $socket->close;
    
    unless (Fn->contains($buffer->to_string, "google.com")) {
      return 0;
    }
    
    return 1;
  }
  
  static method read : int ($ssl : Net::SSLeay, $fd : int, $timeout : int, $buffer : mutable string, $length : int = -1, $offset : int = 0) {
    
    my $read_length = -1;
    while (1) {
      eval { $read_length = $ssl->read($buffer, $length, $offset); }
      
      if ($@) {
        my $again = Sys::Socket::Errno->is_read_again(Sys::Socket::Errno->errno);
        
        if ($again) {
          Go->gosched_io_read($fd, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
    
    return $read_length;
  }
  
  static method ASN1_ENUMERATED : int () {
    
    my $object = Net::SSLeay::ASN1_ENUMERATED->new;
    
    unless ($object is_type Net::SSLeay::ASN1_ENUMERATED) {
      return 0;
    }
    
    $object->set_int64(Fn->LONG_MIN);
    
    unless ($object->get_int64 == Fn->LONG_MIN) {
      return 0;
    }
    
    return 1;
  }
  
  static method ASN1_INTEGER : int () {
    
    my $object = Net::SSLeay::ASN1_INTEGER->new;
    
    unless ($object is_type Net::SSLeay::ASN1_INTEGER) {
      return 0;
    }
    
    $object->set_int64(Fn->LONG_MIN);
    
    unless ($object->get_int64 == Fn->LONG_MIN) {
      return 0;
    }
    
    return 1;
  }
  
  static method ASN1_OBJECT : int () {
    
    my $object = Net::SSLeay::ASN1_OBJECT->new;
    
    unless ($object is_type Net::SSLeay::ASN1_OBJECT) {
      return 0;
    }
    
    return 1;
  }
  
  static method ASN1_STRING : int () {
    
    my $object = Net::SSLeay::ASN1_STRING->new;
    
    unless ($object is_type Net::SSLeay::ASN1_STRING) {
      return 0;
    }
    
    $object->set("abc");
    
    unless ($object->get0_data eq "abc") {
      return 0;
    }
    
    unless ($object->length == 3) {
      return 0;
    }
    
    return 1;
  }
  
  static method ASN1_OCTET_STRING : int () {
    
    my $object = Net::SSLeay::ASN1_OCTET_STRING->new;
    
    unless ($object is_type Net::SSLeay::ASN1_OCTET_STRING) {
      return 0;
    }
    
    $object->set("abc");
    
    unless ($object->get0_data eq "abc") {
      return 0;
    }
    
    unless ($object->length == 3) {
      return 0;
    }
    
    return 1;
  }
  
  static method ASN1_TIME : int () {
    
    my $object = Net::SSLeay::ASN1_TIME->new;
    
    unless ($object is_type Net::SSLeay::ASN1_TIME) {
      return 0;
    }
    
    $object->set(1);
    
    my $tm = Sys::Time::Tm->new;
    
    $object->to_tm($tm);
    
    unless ($tm->tm_year == 70) {
      return 0;
    }
    
    unless ($tm->tm_mon == 0) {
      return 0;
    }
    
    unless ($tm->tm_mday == 1) {
      return 0;
    }
    
    unless ($tm->tm_hour == 0) {
      return 0;
    }
    
    unless ($tm->tm_min == 0) {
      return 0;
    }
    
    unless ($tm->tm_sec == 1) {
      return 0;
    }
    
    my $bio = Net::SSLeay::BIO->new;
    
    $object->print($bio);
    
    my $buffer = (mutable string)new_string_len 256;
    my $read_length = $bio->read($buffer);
    Fn->shorten($buffer, $read_length);
    
    unless (Fn->contains($buffer, "1970")) {
      return 0;
    }
    
    unless (Fn->contains($buffer, "00:00:01")) {
      return 0;
    }
    
    return 1;
  }
  
  static method ASN1_GENERALIZEDTIME : int () {
    
    my $object = Net::SSLeay::ASN1_GENERALIZEDTIME->new;
    
    unless ($object is_type Net::SSLeay::ASN1_GENERALIZEDTIME) {
      return 0;
    }
    
    $object->set(1);
    
    my $bio = Net::SSLeay::BIO->new;
    
    $object->print($bio);
    
    my $buffer = (mutable string)new_string_len 256;
    my $read_length = $bio->read($buffer);
    Fn->shorten($buffer, $read_length);
    
    unless (Fn->contains($buffer, "1970")) {
      return 0;
    }
    
    unless (Fn->contains($buffer, "00:00:01")) {
      return 0;
    }
    
    return 1;
  }
  
  static method OBJ : int () {
    
    {
      my $nid = Net::SSLeay::OBJ->txt2nid("commonName");
      
      unless ($nid == SSL->NID_commonName) {
        return 0;
      }
    }
    
    {
      my $obj = Net::SSLeay::OBJ->nid2obj(SSL->NID_commonName);
      
      unless ($obj) {
        return 0;
      }
      
      my $nid = Net::SSLeay::OBJ->obj2nid($obj);
      
      unless ($nid == SSL->NID_commonName) {
        return 0;
      }
    }
    
    return 1;
  }
  
  static method SSL_METHOD : int () {
    
    {
      my $ssl_method = Net::SSLeay::SSL_METHOD->SSLv23_method;
      unless ($ssl_method is_type Net::SSLeay::SSL_METHOD) {
        return 0;
      }
      
      my $ssl_ctx = Net::SSLeay::SSL_CTX->new($ssl_method);
    }
    
    {
      my $ssl_method = Net::SSLeay::SSL_METHOD->SSLv23_client_method;
      unless ($ssl_method is_type Net::SSLeay::SSL_METHOD) {
        return 0;
      }
      
      my $ssl_ctx = Net::SSLeay::SSL_CTX->new($ssl_method);
    }
    
    {
      my $ssl_method = Net::SSLeay::SSL_METHOD->SSLv23_server_method;
      unless ($ssl_method is_type Net::SSLeay::SSL_METHOD) {
        return 0;
      }
      
      my $ssl_ctx = Net::SSLeay::SSL_CTX->new($ssl_method);
    }
    
    {
      my $ssl_method = Net::SSLeay::SSL_METHOD->TLS_method;
      unless ($ssl_method is_type Net::SSLeay::SSL_METHOD) {
        return 0;
      }
      
      my $ssl_ctx = Net::SSLeay::SSL_CTX->new($ssl_method);
    }
    
    {
      my $ssl_method = Net::SSLeay::SSL_METHOD->TLS_client_method;
      unless ($ssl_method is_type Net::SSLeay::SSL_METHOD) {
        return 0;
      }
      
      my $ssl_ctx = Net::SSLeay::SSL_CTX->new($ssl_method);
    }
    
    {
      my $ssl_method = Net::SSLeay::SSL_METHOD->TLS_server_method;
      unless ($ssl_method is_type Net::SSLeay::SSL_METHOD) {
        return 0;
      }
      
      my $ssl_ctx = Net::SSLeay::SSL_CTX->new($ssl_method);
    }
    
    return 1;
  }
  
  static method BIO : int () {
    
    {
      my $object = Net::SSLeay::BIO->new;
      
      unless ($object is_type Net::SSLeay::BIO) {
        return 0;
      }
      
      $object->write("abc");
      
      my $buffer = (mutable string)new_string_len 3;
      my $read_length = $object->read($buffer);
      
      unless ($read_length == 3) {
        return 0;
      }
      
      unless ($buffer eq "abc") {
        return 0;
      }
    }
    
    {
      my $object = Net::SSLeay::BIO->new;
      
      unless ($object is_type Net::SSLeay::BIO) {
        return 0;
      }
      
      $object->write("abc", 2);
      
      my $buffer = (mutable string)new_string_len 3;
      my $read_length = $object->read($buffer, 2);
      
      unless ($read_length == 2) {
        return 0;
      }
      
      unless ($buffer eq "ab\0") {
        return 0;
      }
    }
    
    {
      my $object = Net::SSLeay::BIO->new_file("$FILE_DIR/simple-cert.cert.pem", "r");
      
      unless ($object is_type Net::SSLeay::BIO) {
        return 0;
      }
      
      my $buffer = (mutable string)new_string_len 3;
      my $read_length = $object->read($buffer, 3);
      
      unless ($read_length == 3) {
        return 0;
      }
      
      unless ($buffer eq "---") {
        return 0;
      }
    }
    return 1;
  }
  
  static method DH : int () {
    
    {
      my $dh = Net::SSLeay::DH->new;
      
      unless ($dh is_type Net::SSLeay::DH) {
        return 0;
      }
    }
    
    return 1;
  }
  
  static method PEM : int () {
    
    {
      
      my $dh_pem = <<'EOS';
-----BEGIN DH PARAMETERS-----
MIIBCAKCAQEAr8wskArj5+1VCVsnWt/RUR7tXkHJ7mGW7XxrLSPOaFyKyWf8lZht
iSY2Lc4oa4Zw8wibGQ3faeQu/s8fvPq/aqTxYmyHPKCMoze77QJHtrYtJAosB9SY
CN7s5Hexxb5/vQ4qlQuOkVrZDiZO9GC4KaH9mJYnCoAsXDhDft6JT0oRVSgtZQnU
gWFKShIm+JVjN94kGs0TcBEesPTK2g8XVHK9H8AtSUb9BwW2qD/T5RmgNABysApO
Ps2vlkxjAHjJcqc3O+OiImKik/X2rtBTZjpKmzN3WWTB0RJZCOWaLlDO81D01o1E
aZecz3Np9KIYey900f+X7zC2bJxEHp95ywIBAg==
-----END DH PARAMETERS-----
EOS
      
      my $bio = Net::SSLeay::BIO->new;
      
      $bio->write($dh_pem);
      
      my $dh = Net::SSLeay::PEM->read_bio_DHparams($bio);
      
      unless ($dh is_type Net::SSLeay::DH) {
        return 0;
      }
      
    }
    
    {
      my $bio = Net::SSLeay::BIO->new_file("$FILE_DIR/simple-cert.cert.pem", "r");
      
      my $x509 = Net::SSLeay::PEM->read_bio_X509($bio);
      
      unless ($x509 is_type Net::SSLeay::X509) {
        return 0;
      }
      
    }
    
    {
      my $bio = Net::SSLeay::BIO->new_file("$FILE_DIR/intermediate-ca.crl.pem", "r");
      
      my $x509_crl = Net::SSLeay::PEM->read_bio_X509_CRL($bio);
      
      unless ($x509_crl is_type Net::SSLeay::X509_CRL) {
        return 0;
      }
      
    }
    
    {
      my $bio = Net::SSLeay::BIO->new_file("$FILE_DIR/intermediate-ca.key.pem", "r");
      
      my $evp_pkey = Net::SSLeay::PEM->read_bio_PrivateKey($bio);
      
      unless ($evp_pkey is_type Net::SSLeay::EVP_PKEY) {
        return 0;
      }
      
    }
    
    return 1;
  }
  
  static method EVP : int () {
    
    {
      my $md = Net::SSLeay::EVP->sha1;
      
      unless ($md is_type Net::SSLeay::EVP_MD) {
        return 0;
      }
    }
    
    {
      my $md = Net::SSLeay::EVP->sha256;
      
      unless ($md is_type Net::SSLeay::EVP_MD) {
        return 0;
      }
    }
    
    {
      my $md = Net::SSLeay::EVP->sha512;
      
      unless ($md is_type Net::SSLeay::EVP_MD) {
        return 0;
      }
    }
    
    {
      my $md = Net::SSLeay::EVP->get_digestbyname("sha512");
      
      unless ($md is_type Net::SSLeay::EVP_MD) {
        return 0;
      }
    }
    
    return 1;
  }
  
  static method OPENSSL_INIT : int () {
    
    {
      my $init_setting = Net::SSLeay::OPENSSL_INIT->new;
      
      unless ($init_setting is_type Net::SSLeay::OPENSSL_INIT_SETTINGS) {
        return 0;
      }
      
      {
        eval  {Net::SSLeay::OPENSSL_INIT->set_config_filename(undef, undef); }
        
        if ($@ && eval_error_id isa_error Error::NotSupported) {
          warn "[Test Skip]Skip tests for Net::SSLeay::OPENSSL_INIT#set_config_filename method.";
        }
        else {
          Net::SSLeay::OPENSSL_INIT->set_config_filename($init_setting, "foo.config");
        }
      }
      
      {
        eval  {Net::SSLeay::OPENSSL_INIT->set_config_file_flags(undef, 0); }
        
        if ($@ && eval_error_id isa_error Error::NotSupported) {
          warn "[Test Skip]Skip tests for Net::SSLeay::OPENSSL_INIT#set_config_file_flags method.";
        }
        else {
          Net::SSLeay::OPENSSL_INIT->set_config_file_flags($init_setting, 0);
        }
      }
      
      {
        eval  {Net::SSLeay::OPENSSL_INIT->set_config_appname(undef, undef); }
        
        if ($@ && eval_error_id isa_error Error::NotSupported) {
          warn "[Test Skip]Skip tests for Net::SSLeay::OPENSSL_INIT#set_config_appname method.";
        }
        else {
          Net::SSLeay::OPENSSL_INIT->set_config_appname($init_setting, "foo");
        }
      }
    }
    
    return 1;
  }
  
  static method OPENSSL : int () {
    
    Net::SSLeay::OPENSSL->add_ssl_algorithms;
    
    Net::SSLeay::OPENSSL->add_all_algorithms;
    
    my $init_setting = Net::SSLeay::OPENSSL_INIT->new;
    
    Net::SSLeay::OPENSSL->init_ssl(0, $init_setting);
    
    return 1;
  }
  
}
